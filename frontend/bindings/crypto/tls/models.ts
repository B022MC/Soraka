// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as x509$0 from "../x509/models.js";

/**
 * ConnectionState records basic TLS details about the connection.
 */
export class ConnectionState {
    /**
     * Version is the TLS version used by the connection (e.g. VersionTLS12).
     */
    "Version": number;

    /**
     * HandshakeComplete is true if the handshake has concluded.
     */
    "HandshakeComplete": boolean;

    /**
     * DidResume is true if this connection was successfully resumed from a
     * previous session with a session ticket or similar mechanism.
     */
    "DidResume": boolean;

    /**
     * CipherSuite is the cipher suite negotiated for the connection (e.g.
     * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).
     */
    "CipherSuite": number;

    /**
     * NegotiatedProtocol is the application protocol negotiated with ALPN.
     */
    "NegotiatedProtocol": string;

    /**
     * NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.
     * 
     * Deprecated: this value is always true.
     */
    "NegotiatedProtocolIsMutual": boolean;

    /**
     * ServerName is the value of the Server Name Indication extension sent by
     * the client. It's available both on the server and on the client side.
     */
    "ServerName": string;

    /**
     * PeerCertificates are the parsed certificates sent by the peer, in the
     * order in which they were sent. The first element is the leaf certificate
     * that the connection is verified against.
     * 
     * On the client side, it can't be empty. On the server side, it can be
     * empty if Config.ClientAuth is not RequireAnyClientCert or
     * RequireAndVerifyClientCert.
     * 
     * PeerCertificates and its contents should not be modified.
     */
    "PeerCertificates": (x509$0.Certificate | null)[];

    /**
     * VerifiedChains is a list of one or more chains where the first element is
     * PeerCertificates[0] and the last element is from Config.RootCAs (on the
     * client side) or Config.ClientCAs (on the server side).
     * 
     * On the client side, it's set if Config.InsecureSkipVerify is false. On
     * the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven
     * (and the peer provided a certificate) or RequireAndVerifyClientCert.
     * 
     * VerifiedChains and its contents should not be modified.
     */
    "VerifiedChains": (x509$0.Certificate | null)[][];

    /**
     * SignedCertificateTimestamps is a list of SCTs provided by the peer
     * through the TLS handshake for the leaf certificate, if any.
     */
    "SignedCertificateTimestamps": string[];

    /**
     * OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)
     * response provided by the peer for the leaf certificate, if any.
     */
    "OCSPResponse": string;

    /**
     * TLSUnique contains the "tls-unique" channel binding value (see RFC 5929,
     * Section 3). This value will be nil for TLS 1.3 connections and for
     * resumed connections that don't support Extended Master Secret (RFC 7627).
     */
    "TLSUnique": string;

    /**
     * ECHAccepted indicates if Encrypted Client Hello was offered by the client
     * and accepted by the server. Currently, ECH is supported only on the
     * client side.
     */
    "ECHAccepted": boolean;

    /** Creates a new ConnectionState instance. */
    constructor($$source: Partial<ConnectionState> = {}) {
        if (!("Version" in $$source)) {
            this["Version"] = 0;
        }
        if (!("HandshakeComplete" in $$source)) {
            this["HandshakeComplete"] = false;
        }
        if (!("DidResume" in $$source)) {
            this["DidResume"] = false;
        }
        if (!("CipherSuite" in $$source)) {
            this["CipherSuite"] = 0;
        }
        if (!("NegotiatedProtocol" in $$source)) {
            this["NegotiatedProtocol"] = "";
        }
        if (!("NegotiatedProtocolIsMutual" in $$source)) {
            this["NegotiatedProtocolIsMutual"] = false;
        }
        if (!("ServerName" in $$source)) {
            this["ServerName"] = "";
        }
        if (!("PeerCertificates" in $$source)) {
            this["PeerCertificates"] = [];
        }
        if (!("VerifiedChains" in $$source)) {
            this["VerifiedChains"] = [];
        }
        if (!("SignedCertificateTimestamps" in $$source)) {
            this["SignedCertificateTimestamps"] = [];
        }
        if (!("OCSPResponse" in $$source)) {
            this["OCSPResponse"] = "";
        }
        if (!("TLSUnique" in $$source)) {
            this["TLSUnique"] = "";
        }
        if (!("ECHAccepted" in $$source)) {
            this["ECHAccepted"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ConnectionState instance from a string or object.
     */
    static createFrom($$source: any = {}): ConnectionState {
        const $$createField7_0 = $$createType2;
        const $$createField8_0 = $$createType3;
        const $$createField9_0 = $$createType4;
        const $$createField10_0 = $Create.ByteSlice;
        const $$createField11_0 = $Create.ByteSlice;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("PeerCertificates" in $$parsedSource) {
            $$parsedSource["PeerCertificates"] = $$createField7_0($$parsedSource["PeerCertificates"]);
        }
        if ("VerifiedChains" in $$parsedSource) {
            $$parsedSource["VerifiedChains"] = $$createField8_0($$parsedSource["VerifiedChains"]);
        }
        if ("SignedCertificateTimestamps" in $$parsedSource) {
            $$parsedSource["SignedCertificateTimestamps"] = $$createField9_0($$parsedSource["SignedCertificateTimestamps"]);
        }
        if ("OCSPResponse" in $$parsedSource) {
            $$parsedSource["OCSPResponse"] = $$createField10_0($$parsedSource["OCSPResponse"]);
        }
        if ("TLSUnique" in $$parsedSource) {
            $$parsedSource["TLSUnique"] = $$createField11_0($$parsedSource["TLSUnique"]);
        }
        return new ConnectionState($$parsedSource as Partial<ConnectionState>);
    }
}

// Private type creation functions
const $$createType0 = x509$0.Certificate.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
const $$createType2 = $Create.Array($$createType1);
const $$createType3 = $Create.Array($$createType2);
const $$createType4 = $Create.Array($Create.ByteSlice);
