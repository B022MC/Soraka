// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as asn1$0 from "../../../encoding/asn1/models.js";

/**
 * AttributeTypeAndValue mirrors the ASN.1 structure of the same name in
 * RFC 5280, Section 4.1.2.4.
 */
export class AttributeTypeAndValue {
    "Type": asn1$0.ObjectIdentifier;
    "Value": any;

    /** Creates a new AttributeTypeAndValue instance. */
    constructor($$source: Partial<AttributeTypeAndValue> = {}) {
        if (!("Type" in $$source)) {
            this["Type"] = ([] as asn1$0.ObjectIdentifier);
        }
        if (!("Value" in $$source)) {
            this["Value"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new AttributeTypeAndValue instance from a string or object.
     */
    static createFrom($$source: any = {}): AttributeTypeAndValue {
        const $$createField0_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Type" in $$parsedSource) {
            $$parsedSource["Type"] = $$createField0_0($$parsedSource["Type"]);
        }
        return new AttributeTypeAndValue($$parsedSource as Partial<AttributeTypeAndValue>);
    }
}

/**
 * Extension represents the ASN.1 structure of the same name. See RFC
 * 5280, section 4.2.
 */
export class Extension {
    "Id": asn1$0.ObjectIdentifier;
    "Critical": boolean;
    "Value": string;

    /** Creates a new Extension instance. */
    constructor($$source: Partial<Extension> = {}) {
        if (!("Id" in $$source)) {
            this["Id"] = ([] as asn1$0.ObjectIdentifier);
        }
        if (!("Critical" in $$source)) {
            this["Critical"] = false;
        }
        if (!("Value" in $$source)) {
            this["Value"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Extension instance from a string or object.
     */
    static createFrom($$source: any = {}): Extension {
        const $$createField0_0 = $$createType0;
        const $$createField2_0 = $Create.ByteSlice;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Id" in $$parsedSource) {
            $$parsedSource["Id"] = $$createField0_0($$parsedSource["Id"]);
        }
        if ("Value" in $$parsedSource) {
            $$parsedSource["Value"] = $$createField2_0($$parsedSource["Value"]);
        }
        return new Extension($$parsedSource as Partial<Extension>);
    }
}

/**
 * Name represents an X.509 distinguished name. This only includes the common
 * elements of a DN. Note that Name is only an approximation of the X.509
 * structure. If an accurate representation is needed, asn1.Unmarshal the raw
 * subject or issuer as an [RDNSequence].
 */
export class Name {
    "Country": string[];
    "Organization": string[];
    "OrganizationalUnit": string[];
    "Locality": string[];
    "Province": string[];
    "StreetAddress": string[];
    "PostalCode": string[];
    "SerialNumber": string;
    "CommonName": string;

    /**
     * Names contains all parsed attributes. When parsing distinguished names,
     * this can be used to extract non-standard attributes that are not parsed
     * by this package. When marshaling to RDNSequences, the Names field is
     * ignored, see ExtraNames.
     */
    "Names": AttributeTypeAndValue[];

    /**
     * ExtraNames contains attributes to be copied, raw, into any marshaled
     * distinguished names. Values override any attributes with the same OID.
     * The ExtraNames field is not populated when parsing, see Names.
     */
    "ExtraNames": AttributeTypeAndValue[];

    /** Creates a new Name instance. */
    constructor($$source: Partial<Name> = {}) {
        if (!("Country" in $$source)) {
            this["Country"] = [];
        }
        if (!("Organization" in $$source)) {
            this["Organization"] = [];
        }
        if (!("OrganizationalUnit" in $$source)) {
            this["OrganizationalUnit"] = [];
        }
        if (!("Locality" in $$source)) {
            this["Locality"] = [];
        }
        if (!("Province" in $$source)) {
            this["Province"] = [];
        }
        if (!("StreetAddress" in $$source)) {
            this["StreetAddress"] = [];
        }
        if (!("PostalCode" in $$source)) {
            this["PostalCode"] = [];
        }
        if (!("SerialNumber" in $$source)) {
            this["SerialNumber"] = "";
        }
        if (!("CommonName" in $$source)) {
            this["CommonName"] = "";
        }
        if (!("Names" in $$source)) {
            this["Names"] = [];
        }
        if (!("ExtraNames" in $$source)) {
            this["ExtraNames"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Name instance from a string or object.
     */
    static createFrom($$source: any = {}): Name {
        const $$createField0_0 = $$createType2;
        const $$createField0_1 = $$createType2;
        const $$createField0_2 = $$createType2;
        const $$createField1_0 = $$createType2;
        const $$createField1_1 = $$createType2;
        const $$createField2_0 = $$createType2;
        const $$createField2_1 = $$createType2;
        const $$createField4_0 = $$createType4;
        const $$createField5_0 = $$createType4;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Country" in $$parsedSource) {
            $$parsedSource["Country"] = $$createField0_0($$parsedSource["Country"]);
        }
        if ("Organization" in $$parsedSource) {
            $$parsedSource["Organization"] = $$createField0_1($$parsedSource["Organization"]);
        }
        if ("OrganizationalUnit" in $$parsedSource) {
            $$parsedSource["OrganizationalUnit"] = $$createField0_2($$parsedSource["OrganizationalUnit"]);
        }
        if ("Locality" in $$parsedSource) {
            $$parsedSource["Locality"] = $$createField1_0($$parsedSource["Locality"]);
        }
        if ("Province" in $$parsedSource) {
            $$parsedSource["Province"] = $$createField1_1($$parsedSource["Province"]);
        }
        if ("StreetAddress" in $$parsedSource) {
            $$parsedSource["StreetAddress"] = $$createField2_0($$parsedSource["StreetAddress"]);
        }
        if ("PostalCode" in $$parsedSource) {
            $$parsedSource["PostalCode"] = $$createField2_1($$parsedSource["PostalCode"]);
        }
        if ("Names" in $$parsedSource) {
            $$parsedSource["Names"] = $$createField4_0($$parsedSource["Names"]);
        }
        if ("ExtraNames" in $$parsedSource) {
            $$parsedSource["ExtraNames"] = $$createField5_0($$parsedSource["ExtraNames"]);
        }
        return new Name($$parsedSource as Partial<Name>);
    }
}

// Private type creation functions
var $$createType0 = (function $$initCreateType0(...args): any {
    if ($$createType0 === $$initCreateType0) {
        $$createType0 = $$createType1;
    }
    return $$createType0(...args);
});
const $$createType1 = $Create.Array($Create.Any);
const $$createType2 = $Create.Array($Create.Any);
const $$createType3 = AttributeTypeAndValue.createFrom;
const $$createType4 = $Create.Array($$createType3);
