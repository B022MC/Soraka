// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as pkix$0 from "./pkix/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as asn1$0 from "../../encoding/asn1/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as big$0 from "../../math/big/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as net$0 from "../../net/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as url$0 from "../../net/url/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../time/models.js";

/**
 * A Certificate represents an X.509 certificate.
 */
export class Certificate {
    /**
     * Complete ASN.1 DER content (certificate, signature algorithm and signature).
     */
    "Raw": string;

    /**
     * Certificate part of raw ASN.1 DER content.
     */
    "RawTBSCertificate": string;

    /**
     * DER encoded SubjectPublicKeyInfo.
     */
    "RawSubjectPublicKeyInfo": string;

    /**
     * DER encoded Subject
     */
    "RawSubject": string;

    /**
     * DER encoded Issuer
     */
    "RawIssuer": string;
    "Signature": string;
    "SignatureAlgorithm": SignatureAlgorithm;
    "PublicKeyAlgorithm": PublicKeyAlgorithm;
    "PublicKey": any;
    "Version": number;
    "SerialNumber": big$0.Int | null;
    "Issuer": pkix$0.Name;
    "Subject": pkix$0.Name;

    /**
     * Validity bounds.
     */
    "NotBefore": time$0.Time;
    "NotAfter": time$0.Time;
    "KeyUsage": KeyUsage;

    /**
     * Extensions contains raw X.509 extensions. When parsing certificates,
     * this can be used to extract non-critical extensions that are not
     * parsed by this package. When marshaling certificates, the Extensions
     * field is ignored, see ExtraExtensions.
     */
    "Extensions": pkix$0.Extension[];

    /**
     * ExtraExtensions contains extensions to be copied, raw, into any
     * marshaled certificates. Values override any extensions that would
     * otherwise be produced based on the other fields. The ExtraExtensions
     * field is not populated when parsing certificates, see Extensions.
     */
    "ExtraExtensions": pkix$0.Extension[];

    /**
     * UnhandledCriticalExtensions contains a list of extension IDs that
     * were not (fully) processed when parsing. Verify will fail if this
     * slice is non-empty, unless verification is delegated to an OS
     * library which understands all the critical extensions.
     * 
     * Users can access these extensions using Extensions and can remove
     * elements from this slice if they believe that they have been
     * handled.
     */
    "UnhandledCriticalExtensions": asn1$0.ObjectIdentifier[];

    /**
     * Sequence of extended key usages.
     */
    "ExtKeyUsage": ExtKeyUsage[];

    /**
     * Encountered extended key usages unknown to this package.
     */
    "UnknownExtKeyUsage": asn1$0.ObjectIdentifier[];

    /**
     * BasicConstraintsValid indicates whether IsCA, MaxPathLen,
     * and MaxPathLenZero are valid.
     */
    "BasicConstraintsValid": boolean;
    "IsCA": boolean;

    /**
     * MaxPathLen and MaxPathLenZero indicate the presence and
     * value of the BasicConstraints' "pathLenConstraint".
     * 
     * When parsing a certificate, a positive non-zero MaxPathLen
     * means that the field was specified, -1 means it was unset,
     * and MaxPathLenZero being true mean that the field was
     * explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
     * should be treated equivalent to -1 (unset).
     * 
     * When generating a certificate, an unset pathLenConstraint
     * can be requested with either MaxPathLen == -1 or using the
     * zero value for both MaxPathLen and MaxPathLenZero.
     */
    "MaxPathLen": number;

    /**
     * MaxPathLenZero indicates that BasicConstraintsValid==true
     * and MaxPathLen==0 should be interpreted as an actual
     * maximum path length of zero. Otherwise, that combination is
     * interpreted as MaxPathLen not being set.
     */
    "MaxPathLenZero": boolean;
    "SubjectKeyId": string;
    "AuthorityKeyId": string;

    /**
     * RFC 5280, 4.2.2.1 (Authority Information Access)
     */
    "OCSPServer": string[];
    "IssuingCertificateURL": string[];

    /**
     * Subject Alternate Name values. (Note that these values may not be valid
     * if invalid values were contained within a parsed certificate. For
     * example, an element of DNSNames may not be a valid DNS domain name.)
     */
    "DNSNames": string[];
    "EmailAddresses": string[];
    "IPAddresses": net$0.IP[];
    "URIs": (url$0.URL | null)[];

    /**
     * Name constraints
     * if true then the name constraints are marked critical.
     */
    "PermittedDNSDomainsCritical": boolean;
    "PermittedDNSDomains": string[];
    "ExcludedDNSDomains": string[];
    "PermittedIPRanges": (net$0.IPNet | null)[];
    "ExcludedIPRanges": (net$0.IPNet | null)[];
    "PermittedEmailAddresses": string[];
    "ExcludedEmailAddresses": string[];
    "PermittedURIDomains": string[];
    "ExcludedURIDomains": string[];

    /**
     * CRL Distribution Points
     */
    "CRLDistributionPoints": string[];

    /**
     * PolicyIdentifiers contains asn1.ObjectIdentifiers, the components
     * of which are limited to int32. If a certificate contains a policy which
     * cannot be represented by asn1.ObjectIdentifier, it will not be included in
     * PolicyIdentifiers, but will be present in Policies, which contains all parsed
     * policy OIDs.
     */
    "PolicyIdentifiers": asn1$0.ObjectIdentifier[];

    /**
     * Policies contains all policy identifiers included in the certificate.
     * In Go 1.22, encoding/gob cannot handle and ignores this field.
     */
    "Policies": OID[];

    /** Creates a new Certificate instance. */
    constructor($$source: Partial<Certificate> = {}) {
        if (!("Raw" in $$source)) {
            this["Raw"] = "";
        }
        if (!("RawTBSCertificate" in $$source)) {
            this["RawTBSCertificate"] = "";
        }
        if (!("RawSubjectPublicKeyInfo" in $$source)) {
            this["RawSubjectPublicKeyInfo"] = "";
        }
        if (!("RawSubject" in $$source)) {
            this["RawSubject"] = "";
        }
        if (!("RawIssuer" in $$source)) {
            this["RawIssuer"] = "";
        }
        if (!("Signature" in $$source)) {
            this["Signature"] = "";
        }
        if (!("SignatureAlgorithm" in $$source)) {
            this["SignatureAlgorithm"] = (0 as SignatureAlgorithm);
        }
        if (!("PublicKeyAlgorithm" in $$source)) {
            this["PublicKeyAlgorithm"] = (0 as PublicKeyAlgorithm);
        }
        if (!("PublicKey" in $$source)) {
            this["PublicKey"] = null;
        }
        if (!("Version" in $$source)) {
            this["Version"] = 0;
        }
        if (!("SerialNumber" in $$source)) {
            this["SerialNumber"] = null;
        }
        if (!("Issuer" in $$source)) {
            this["Issuer"] = (new pkix$0.Name());
        }
        if (!("Subject" in $$source)) {
            this["Subject"] = (new pkix$0.Name());
        }
        if (!("NotBefore" in $$source)) {
            this["NotBefore"] = null;
        }
        if (!("NotAfter" in $$source)) {
            this["NotAfter"] = null;
        }
        if (!("KeyUsage" in $$source)) {
            this["KeyUsage"] = (0 as KeyUsage);
        }
        if (!("Extensions" in $$source)) {
            this["Extensions"] = [];
        }
        if (!("ExtraExtensions" in $$source)) {
            this["ExtraExtensions"] = [];
        }
        if (!("UnhandledCriticalExtensions" in $$source)) {
            this["UnhandledCriticalExtensions"] = [];
        }
        if (!("ExtKeyUsage" in $$source)) {
            this["ExtKeyUsage"] = [];
        }
        if (!("UnknownExtKeyUsage" in $$source)) {
            this["UnknownExtKeyUsage"] = [];
        }
        if (!("BasicConstraintsValid" in $$source)) {
            this["BasicConstraintsValid"] = false;
        }
        if (!("IsCA" in $$source)) {
            this["IsCA"] = false;
        }
        if (!("MaxPathLen" in $$source)) {
            this["MaxPathLen"] = 0;
        }
        if (!("MaxPathLenZero" in $$source)) {
            this["MaxPathLenZero"] = false;
        }
        if (!("SubjectKeyId" in $$source)) {
            this["SubjectKeyId"] = "";
        }
        if (!("AuthorityKeyId" in $$source)) {
            this["AuthorityKeyId"] = "";
        }
        if (!("OCSPServer" in $$source)) {
            this["OCSPServer"] = [];
        }
        if (!("IssuingCertificateURL" in $$source)) {
            this["IssuingCertificateURL"] = [];
        }
        if (!("DNSNames" in $$source)) {
            this["DNSNames"] = [];
        }
        if (!("EmailAddresses" in $$source)) {
            this["EmailAddresses"] = [];
        }
        if (!("IPAddresses" in $$source)) {
            this["IPAddresses"] = [];
        }
        if (!("URIs" in $$source)) {
            this["URIs"] = [];
        }
        if (!("PermittedDNSDomainsCritical" in $$source)) {
            this["PermittedDNSDomainsCritical"] = false;
        }
        if (!("PermittedDNSDomains" in $$source)) {
            this["PermittedDNSDomains"] = [];
        }
        if (!("ExcludedDNSDomains" in $$source)) {
            this["ExcludedDNSDomains"] = [];
        }
        if (!("PermittedIPRanges" in $$source)) {
            this["PermittedIPRanges"] = [];
        }
        if (!("ExcludedIPRanges" in $$source)) {
            this["ExcludedIPRanges"] = [];
        }
        if (!("PermittedEmailAddresses" in $$source)) {
            this["PermittedEmailAddresses"] = [];
        }
        if (!("ExcludedEmailAddresses" in $$source)) {
            this["ExcludedEmailAddresses"] = [];
        }
        if (!("PermittedURIDomains" in $$source)) {
            this["PermittedURIDomains"] = [];
        }
        if (!("ExcludedURIDomains" in $$source)) {
            this["ExcludedURIDomains"] = [];
        }
        if (!("CRLDistributionPoints" in $$source)) {
            this["CRLDistributionPoints"] = [];
        }
        if (!("PolicyIdentifiers" in $$source)) {
            this["PolicyIdentifiers"] = [];
        }
        if (!("Policies" in $$source)) {
            this["Policies"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Certificate instance from a string or object.
     */
    static createFrom($$source: any = {}): Certificate {
        const $$createField0_0 = $Create.ByteSlice;
        const $$createField1_0 = $Create.ByteSlice;
        const $$createField2_0 = $Create.ByteSlice;
        const $$createField3_0 = $Create.ByteSlice;
        const $$createField4_0 = $Create.ByteSlice;
        const $$createField5_0 = $Create.ByteSlice;
        const $$createField11_0 = $$createType0;
        const $$createField12_0 = $$createType0;
        const $$createField15_0 = $$createType2;
        const $$createField16_0 = $$createType2;
        const $$createField17_0 = $$createType5;
        const $$createField18_0 = $$createType6;
        const $$createField19_0 = $$createType5;
        const $$createField24_0 = $Create.ByteSlice;
        const $$createField25_0 = $Create.ByteSlice;
        const $$createField26_0 = $$createType7;
        const $$createField27_0 = $$createType7;
        const $$createField28_0 = $$createType7;
        const $$createField29_0 = $$createType7;
        const $$createField30_0 = $$createType8;
        const $$createField31_0 = $$createType11;
        const $$createField33_0 = $$createType7;
        const $$createField34_0 = $$createType7;
        const $$createField35_0 = $$createType14;
        const $$createField36_0 = $$createType14;
        const $$createField37_0 = $$createType7;
        const $$createField38_0 = $$createType7;
        const $$createField39_0 = $$createType7;
        const $$createField40_0 = $$createType7;
        const $$createField41_0 = $$createType7;
        const $$createField42_0 = $$createType5;
        const $$createField43_0 = $$createType15;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Raw" in $$parsedSource) {
            $$parsedSource["Raw"] = $$createField0_0($$parsedSource["Raw"]);
        }
        if ("RawTBSCertificate" in $$parsedSource) {
            $$parsedSource["RawTBSCertificate"] = $$createField1_0($$parsedSource["RawTBSCertificate"]);
        }
        if ("RawSubjectPublicKeyInfo" in $$parsedSource) {
            $$parsedSource["RawSubjectPublicKeyInfo"] = $$createField2_0($$parsedSource["RawSubjectPublicKeyInfo"]);
        }
        if ("RawSubject" in $$parsedSource) {
            $$parsedSource["RawSubject"] = $$createField3_0($$parsedSource["RawSubject"]);
        }
        if ("RawIssuer" in $$parsedSource) {
            $$parsedSource["RawIssuer"] = $$createField4_0($$parsedSource["RawIssuer"]);
        }
        if ("Signature" in $$parsedSource) {
            $$parsedSource["Signature"] = $$createField5_0($$parsedSource["Signature"]);
        }
        if ("Issuer" in $$parsedSource) {
            $$parsedSource["Issuer"] = $$createField11_0($$parsedSource["Issuer"]);
        }
        if ("Subject" in $$parsedSource) {
            $$parsedSource["Subject"] = $$createField12_0($$parsedSource["Subject"]);
        }
        if ("Extensions" in $$parsedSource) {
            $$parsedSource["Extensions"] = $$createField15_0($$parsedSource["Extensions"]);
        }
        if ("ExtraExtensions" in $$parsedSource) {
            $$parsedSource["ExtraExtensions"] = $$createField16_0($$parsedSource["ExtraExtensions"]);
        }
        if ("UnhandledCriticalExtensions" in $$parsedSource) {
            $$parsedSource["UnhandledCriticalExtensions"] = $$createField17_0($$parsedSource["UnhandledCriticalExtensions"]);
        }
        if ("ExtKeyUsage" in $$parsedSource) {
            $$parsedSource["ExtKeyUsage"] = $$createField18_0($$parsedSource["ExtKeyUsage"]);
        }
        if ("UnknownExtKeyUsage" in $$parsedSource) {
            $$parsedSource["UnknownExtKeyUsage"] = $$createField19_0($$parsedSource["UnknownExtKeyUsage"]);
        }
        if ("SubjectKeyId" in $$parsedSource) {
            $$parsedSource["SubjectKeyId"] = $$createField24_0($$parsedSource["SubjectKeyId"]);
        }
        if ("AuthorityKeyId" in $$parsedSource) {
            $$parsedSource["AuthorityKeyId"] = $$createField25_0($$parsedSource["AuthorityKeyId"]);
        }
        if ("OCSPServer" in $$parsedSource) {
            $$parsedSource["OCSPServer"] = $$createField26_0($$parsedSource["OCSPServer"]);
        }
        if ("IssuingCertificateURL" in $$parsedSource) {
            $$parsedSource["IssuingCertificateURL"] = $$createField27_0($$parsedSource["IssuingCertificateURL"]);
        }
        if ("DNSNames" in $$parsedSource) {
            $$parsedSource["DNSNames"] = $$createField28_0($$parsedSource["DNSNames"]);
        }
        if ("EmailAddresses" in $$parsedSource) {
            $$parsedSource["EmailAddresses"] = $$createField29_0($$parsedSource["EmailAddresses"]);
        }
        if ("IPAddresses" in $$parsedSource) {
            $$parsedSource["IPAddresses"] = $$createField30_0($$parsedSource["IPAddresses"]);
        }
        if ("URIs" in $$parsedSource) {
            $$parsedSource["URIs"] = $$createField31_0($$parsedSource["URIs"]);
        }
        if ("PermittedDNSDomains" in $$parsedSource) {
            $$parsedSource["PermittedDNSDomains"] = $$createField33_0($$parsedSource["PermittedDNSDomains"]);
        }
        if ("ExcludedDNSDomains" in $$parsedSource) {
            $$parsedSource["ExcludedDNSDomains"] = $$createField34_0($$parsedSource["ExcludedDNSDomains"]);
        }
        if ("PermittedIPRanges" in $$parsedSource) {
            $$parsedSource["PermittedIPRanges"] = $$createField35_0($$parsedSource["PermittedIPRanges"]);
        }
        if ("ExcludedIPRanges" in $$parsedSource) {
            $$parsedSource["ExcludedIPRanges"] = $$createField36_0($$parsedSource["ExcludedIPRanges"]);
        }
        if ("PermittedEmailAddresses" in $$parsedSource) {
            $$parsedSource["PermittedEmailAddresses"] = $$createField37_0($$parsedSource["PermittedEmailAddresses"]);
        }
        if ("ExcludedEmailAddresses" in $$parsedSource) {
            $$parsedSource["ExcludedEmailAddresses"] = $$createField38_0($$parsedSource["ExcludedEmailAddresses"]);
        }
        if ("PermittedURIDomains" in $$parsedSource) {
            $$parsedSource["PermittedURIDomains"] = $$createField39_0($$parsedSource["PermittedURIDomains"]);
        }
        if ("ExcludedURIDomains" in $$parsedSource) {
            $$parsedSource["ExcludedURIDomains"] = $$createField40_0($$parsedSource["ExcludedURIDomains"]);
        }
        if ("CRLDistributionPoints" in $$parsedSource) {
            $$parsedSource["CRLDistributionPoints"] = $$createField41_0($$parsedSource["CRLDistributionPoints"]);
        }
        if ("PolicyIdentifiers" in $$parsedSource) {
            $$parsedSource["PolicyIdentifiers"] = $$createField42_0($$parsedSource["PolicyIdentifiers"]);
        }
        if ("Policies" in $$parsedSource) {
            $$parsedSource["Policies"] = $$createField43_0($$parsedSource["Policies"]);
        }
        return new Certificate($$parsedSource as Partial<Certificate>);
    }
}

/**
 * ExtKeyUsage represents an extended set of actions that are valid for a given key.
 * Each of the ExtKeyUsage* constants define a unique action.
 */
export enum ExtKeyUsage {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    ExtKeyUsageAny = 0,
    ExtKeyUsageServerAuth = 1,
    ExtKeyUsageClientAuth = 2,
    ExtKeyUsageCodeSigning = 3,
    ExtKeyUsageEmailProtection = 4,
    ExtKeyUsageIPSECEndSystem = 5,
    ExtKeyUsageIPSECTunnel = 6,
    ExtKeyUsageIPSECUser = 7,
    ExtKeyUsageTimeStamping = 8,
    ExtKeyUsageOCSPSigning = 9,
    ExtKeyUsageMicrosoftServerGatedCrypto = 10,
    ExtKeyUsageNetscapeServerGatedCrypto = 11,
    ExtKeyUsageMicrosoftCommercialCodeSigning = 12,
    ExtKeyUsageMicrosoftKernelCodeSigning = 13,
};

/**
 * KeyUsage represents the set of actions that are valid for a given key. It's
 * a bitmap of the KeyUsage* constants.
 */
export enum KeyUsage {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    KeyUsageDigitalSignature = 1,
    KeyUsageContentCommitment = 2,
    KeyUsageKeyEncipherment = 4,
    KeyUsageDataEncipherment = 8,
    KeyUsageKeyAgreement = 16,
    KeyUsageCertSign = 32,
    KeyUsageCRLSign = 64,
    KeyUsageEncipherOnly = 128,
    KeyUsageDecipherOnly = 256,
};

/**
 * An OID represents an ASN.1 OBJECT IDENTIFIER.
 */
export type OID = string;

export enum PublicKeyAlgorithm {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    UnknownPublicKeyAlgorithm = 0,
    RSA = 1,

    /**
     * Only supported for parsing.
     */
    DSA = 2,
    ECDSA = 3,
    Ed25519 = 4,
};

export enum SignatureAlgorithm {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    UnknownSignatureAlgorithm = 0,

    /**
     * Unsupported.
     */
    MD2WithRSA = 1,

    /**
     * Only supported for signing, not verification.
     */
    MD5WithRSA = 2,

    /**
     * Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.
     */
    SHA1WithRSA = 3,
    SHA256WithRSA = 4,
    SHA384WithRSA = 5,
    SHA512WithRSA = 6,

    /**
     * Unsupported.
     */
    DSAWithSHA1 = 7,

    /**
     * Unsupported.
     */
    DSAWithSHA256 = 8,

    /**
     * Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.
     */
    ECDSAWithSHA1 = 9,
    ECDSAWithSHA256 = 10,
    ECDSAWithSHA384 = 11,
    ECDSAWithSHA512 = 12,
    SHA256WithRSAPSS = 13,
    SHA384WithRSAPSS = 14,
    SHA512WithRSAPSS = 15,
    PureEd25519 = 16,
};

// Private type creation functions
const $$createType0 = pkix$0.Name.createFrom;
const $$createType1 = pkix$0.Extension.createFrom;
const $$createType2 = $Create.Array($$createType1);
var $$createType3 = (function $$initCreateType3(...args): any {
    if ($$createType3 === $$initCreateType3) {
        $$createType3 = $$createType4;
    }
    return $$createType3(...args);
});
const $$createType4 = $Create.Array($Create.Any);
const $$createType5 = $Create.Array($$createType3);
const $$createType6 = $Create.Array($Create.Any);
const $$createType7 = $Create.Array($Create.Any);
const $$createType8 = $Create.Array($Create.Any);
const $$createType9 = url$0.URL.createFrom;
const $$createType10 = $Create.Nullable($$createType9);
const $$createType11 = $Create.Array($$createType10);
const $$createType12 = net$0.IPNet.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = $Create.Array($$createType13);
const $$createType15 = $Create.Array($Create.Any);
