// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as tls$0 from "../../crypto/tls/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as io$0 from "../../io/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as multipart$0 from "../../mime/multipart/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as url$0 from "../url/models.js";

/**
 * A Header represents the key-value pairs in an HTTP header.
 * 
 * The keys should be in canonical form, as returned by
 * [CanonicalHeaderKey].
 */
export type Header = { [_: string]: string[] };

/**
 * A Request represents an HTTP request received by a server
 * or to be sent by a client.
 * 
 * The field semantics differ slightly between client and server
 * usage. In addition to the notes on the fields below, see the
 * documentation for [Request.Write] and [RoundTripper].
 */
export class Request {
    /**
     * Method specifies the HTTP method (GET, POST, PUT, etc.).
     * For client requests, an empty string means GET.
     */
    "Method": string;

    /**
     * URL specifies either the URI being requested (for server
     * requests) or the URL to access (for client requests).
     * 
     * For server requests, the URL is parsed from the URI
     * supplied on the Request-Line as stored in RequestURI.  For
     * most requests, fields other than Path and RawQuery will be
     * empty. (See RFC 7230, Section 5.3)
     * 
     * For client requests, the URL's Host specifies the server to
     * connect to, while the Request's Host field optionally
     * specifies the Host header value to send in the HTTP
     * request.
     */
    "URL": url$0.URL | null;

    /**
     * The protocol version for incoming server requests.
     * 
     * For client requests, these fields are ignored. The HTTP
     * client code always uses either HTTP/1.1 or HTTP/2.
     * See the docs on Transport for details.
     * "HTTP/1.0"
     */
    "Proto": string;

    /**
     * 1
     */
    "ProtoMajor": number;

    /**
     * 0
     */
    "ProtoMinor": number;

    /**
     * Header contains the request header fields either received
     * by the server or to be sent by the client.
     * 
     * If a server received a request with header lines,
     * 
     * 	Host: example.com
     * 	accept-encoding: gzip, deflate
     * 	Accept-Language: en-us
     * 	fOO: Bar
     * 	foo: two
     * 
     * then
     * 
     * 	Header = map[string][]string{
     * 		"Accept-Encoding": {"gzip, deflate"},
     * 		"Accept-Language": {"en-us"},
     * 		"Foo": {"Bar", "two"},
     * 	}
     * 
     * For incoming requests, the Host header is promoted to the
     * Request.Host field and removed from the Header map.
     * 
     * HTTP defines that header names are case-insensitive. The
     * request parser implements this by using CanonicalHeaderKey,
     * making the first character and any characters following a
     * hyphen uppercase and the rest lowercase.
     * 
     * For client requests, certain headers such as Content-Length
     * and Connection are automatically written when needed and
     * values in Header may be ignored. See the documentation
     * for the Request.Write method.
     */
    "Header": Header;

    /**
     * Body is the request's body.
     * 
     * For client requests, a nil body means the request has no
     * body, such as a GET request. The HTTP Client's Transport
     * is responsible for calling the Close method.
     * 
     * For server requests, the Request Body is always non-nil
     * but will return EOF immediately when no body is present.
     * The Server will close the request body. The ServeHTTP
     * Handler does not need to.
     * 
     * Body must allow Read to be called concurrently with Close.
     * In particular, calling Close should unblock a Read waiting
     * for input.
     */
    "Body": io$0.ReadCloser;

    /**
     * GetBody defines an optional func to return a new copy of
     * Body. It is used for client requests when a redirect requires
     * reading the body more than once. Use of GetBody still
     * requires setting Body.
     * 
     * For server requests, it is unused.
     */
    "GetBody": any;

    /**
     * ContentLength records the length of the associated content.
     * The value -1 indicates that the length is unknown.
     * Values >= 0 indicate that the given number of bytes may
     * be read from Body.
     * 
     * For client requests, a value of 0 with a non-nil Body is
     * also treated as unknown.
     */
    "ContentLength": number;

    /**
     * TransferEncoding lists the transfer encodings from outermost to
     * innermost. An empty list denotes the "identity" encoding.
     * TransferEncoding can usually be ignored; chunked encoding is
     * automatically added and removed as necessary when sending and
     * receiving requests.
     */
    "TransferEncoding": string[];

    /**
     * Close indicates whether to close the connection after
     * replying to this request (for servers) or after sending this
     * request and reading its response (for clients).
     * 
     * For server requests, the HTTP server handles this automatically
     * and this field is not needed by Handlers.
     * 
     * For client requests, setting this field prevents re-use of
     * TCP connections between requests to the same hosts, as if
     * Transport.DisableKeepAlives were set.
     */
    "Close": boolean;

    /**
     * For server requests, Host specifies the host on which the
     * URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this
     * is either the value of the "Host" header or the host name
     * given in the URL itself. For HTTP/2, it is the value of the
     * ":authority" pseudo-header field.
     * It may be of the form "host:port". For international domain
     * names, Host may be in Punycode or Unicode form. Use
     * golang.org/x/net/idna to convert it to either format if
     * needed.
     * To prevent DNS rebinding attacks, server Handlers should
     * validate that the Host header has a value for which the
     * Handler considers itself authoritative. The included
     * ServeMux supports patterns registered to particular host
     * names and thus protects its registered Handlers.
     * 
     * For client requests, Host optionally overrides the Host
     * header to send. If empty, the Request.Write method uses
     * the value of URL.Host. Host may contain an international
     * domain name.
     */
    "Host": string;

    /**
     * Form contains the parsed form data, including both the URL
     * field's query parameters and the PATCH, POST, or PUT form data.
     * This field is only available after ParseForm is called.
     * The HTTP client ignores Form and uses Body instead.
     */
    "Form": url$0.Values;

    /**
     * PostForm contains the parsed form data from PATCH, POST
     * or PUT body parameters.
     * 
     * This field is only available after ParseForm is called.
     * The HTTP client ignores PostForm and uses Body instead.
     */
    "PostForm": url$0.Values;

    /**
     * MultipartForm is the parsed multipart form, including file uploads.
     * This field is only available after ParseMultipartForm is called.
     * The HTTP client ignores MultipartForm and uses Body instead.
     */
    "MultipartForm": multipart$0.Form | null;

    /**
     * Trailer specifies additional headers that are sent after the request
     * body.
     * 
     * For server requests, the Trailer map initially contains only the
     * trailer keys, with nil values. (The client declares which trailers it
     * will later send.)  While the handler is reading from Body, it must
     * not reference Trailer. After reading from Body returns EOF, Trailer
     * can be read again and will contain non-nil values, if they were sent
     * by the client.
     * 
     * For client requests, Trailer must be initialized to a map containing
     * the trailer keys to later send. The values may be nil or their final
     * values. The ContentLength must be 0 or -1, to send a chunked request.
     * After the HTTP request is sent the map values can be updated while
     * the request body is read. Once the body returns EOF, the caller must
     * not mutate Trailer.
     * 
     * Few HTTP clients, servers, or proxies support HTTP trailers.
     */
    "Trailer": Header;

    /**
     * RemoteAddr allows HTTP servers and other software to record
     * the network address that sent the request, usually for
     * logging. This field is not filled in by ReadRequest and
     * has no defined format. The HTTP server in this package
     * sets RemoteAddr to an "IP:port" address before invoking a
     * handler.
     * This field is ignored by the HTTP client.
     */
    "RemoteAddr": string;

    /**
     * RequestURI is the unmodified request-target of the
     * Request-Line (RFC 7230, Section 3.1.1) as sent by the client
     * to a server. Usually the URL field should be used instead.
     * It is an error to set this field in an HTTP client request.
     */
    "RequestURI": string;

    /**
     * TLS allows HTTP servers and other software to record
     * information about the TLS connection on which the request
     * was received. This field is not filled in by ReadRequest.
     * The HTTP server in this package sets the field for
     * TLS-enabled connections before invoking a handler;
     * otherwise it leaves the field nil.
     * This field is ignored by the HTTP client.
     */
    "TLS": tls$0.ConnectionState | null;

    /**
     * Cancel is an optional channel whose closure indicates that the client
     * request should be regarded as canceled. Not all implementations of
     * RoundTripper may support Cancel.
     * 
     * For server requests, this field is not applicable.
     * 
     * Deprecated: Set the Request's context with NewRequestWithContext
     * instead. If a Request's Cancel field and context are both
     * set, it is undefined whether Cancel is respected.
     */
    "Cancel": any;

    /**
     * Response is the redirect response which caused this request
     * to be created. This field is only populated during client
     * redirects.
     */
    "Response": Response | null;

    /**
     * Pattern is the [ServeMux] pattern that matched the request.
     * It is empty if the request was not matched against a pattern.
     */
    "Pattern": string;

    /** Creates a new Request instance. */
    constructor($$source: Partial<Request> = {}) {
        if (!("Method" in $$source)) {
            this["Method"] = "";
        }
        if (!("URL" in $$source)) {
            this["URL"] = null;
        }
        if (!("Proto" in $$source)) {
            this["Proto"] = "";
        }
        if (!("ProtoMajor" in $$source)) {
            this["ProtoMajor"] = 0;
        }
        if (!("ProtoMinor" in $$source)) {
            this["ProtoMinor"] = 0;
        }
        if (!("Header" in $$source)) {
            this["Header"] = ({} as Header);
        }
        if (!("Body" in $$source)) {
            this["Body"] = null;
        }
        if (!("GetBody" in $$source)) {
            this["GetBody"] = null;
        }
        if (!("ContentLength" in $$source)) {
            this["ContentLength"] = 0;
        }
        if (!("TransferEncoding" in $$source)) {
            this["TransferEncoding"] = [];
        }
        if (!("Close" in $$source)) {
            this["Close"] = false;
        }
        if (!("Host" in $$source)) {
            this["Host"] = "";
        }
        if (!("Form" in $$source)) {
            this["Form"] = ({} as url$0.Values);
        }
        if (!("PostForm" in $$source)) {
            this["PostForm"] = ({} as url$0.Values);
        }
        if (!("MultipartForm" in $$source)) {
            this["MultipartForm"] = null;
        }
        if (!("Trailer" in $$source)) {
            this["Trailer"] = ({} as Header);
        }
        if (!("RemoteAddr" in $$source)) {
            this["RemoteAddr"] = "";
        }
        if (!("RequestURI" in $$source)) {
            this["RequestURI"] = "";
        }
        if (!("TLS" in $$source)) {
            this["TLS"] = null;
        }
        if (!("Cancel" in $$source)) {
            this["Cancel"] = null;
        }
        if (!("Response" in $$source)) {
            this["Response"] = null;
        }
        if (!("Pattern" in $$source)) {
            this["Pattern"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Request instance from a string or object.
     */
    static createFrom($$source: any = {}): Request {
        const $$createField1_0 = $$createType1;
        const $$createField5_0 = $$createType2;
        const $$createField9_0 = $$createType3;
        const $$createField12_0 = $$createType5;
        const $$createField13_0 = $$createType5;
        const $$createField14_0 = $$createType7;
        const $$createField15_0 = $$createType2;
        const $$createField18_0 = $$createType9;
        const $$createField20_0 = $$createType11;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("URL" in $$parsedSource) {
            $$parsedSource["URL"] = $$createField1_0($$parsedSource["URL"]);
        }
        if ("Header" in $$parsedSource) {
            $$parsedSource["Header"] = $$createField5_0($$parsedSource["Header"]);
        }
        if ("TransferEncoding" in $$parsedSource) {
            $$parsedSource["TransferEncoding"] = $$createField9_0($$parsedSource["TransferEncoding"]);
        }
        if ("Form" in $$parsedSource) {
            $$parsedSource["Form"] = $$createField12_0($$parsedSource["Form"]);
        }
        if ("PostForm" in $$parsedSource) {
            $$parsedSource["PostForm"] = $$createField13_0($$parsedSource["PostForm"]);
        }
        if ("MultipartForm" in $$parsedSource) {
            $$parsedSource["MultipartForm"] = $$createField14_0($$parsedSource["MultipartForm"]);
        }
        if ("Trailer" in $$parsedSource) {
            $$parsedSource["Trailer"] = $$createField15_0($$parsedSource["Trailer"]);
        }
        if ("TLS" in $$parsedSource) {
            $$parsedSource["TLS"] = $$createField18_0($$parsedSource["TLS"]);
        }
        if ("Response" in $$parsedSource) {
            $$parsedSource["Response"] = $$createField20_0($$parsedSource["Response"]);
        }
        return new Request($$parsedSource as Partial<Request>);
    }
}

/**
 * Response represents the response from an HTTP request.
 * 
 * The [Client] and [Transport] return Responses from servers once
 * the response headers have been received. The response body
 * is streamed on demand as the Body field is read.
 */
export class Response {
    /**
     * e.g. "200 OK"
     */
    "Status": string;

    /**
     * e.g. 200
     */
    "StatusCode": number;

    /**
     * e.g. "HTTP/1.0"
     */
    "Proto": string;

    /**
     * e.g. 1
     */
    "ProtoMajor": number;

    /**
     * e.g. 0
     */
    "ProtoMinor": number;

    /**
     * Header maps header keys to values. If the response had multiple
     * headers with the same key, they may be concatenated, with comma
     * delimiters.  (RFC 7230, section 3.2.2 requires that multiple headers
     * be semantically equivalent to a comma-delimited sequence.) When
     * Header values are duplicated by other fields in this struct (e.g.,
     * ContentLength, TransferEncoding, Trailer), the field values are
     * authoritative.
     * 
     * Keys in the map are canonicalized (see CanonicalHeaderKey).
     */
    "Header": Header;

    /**
     * Body represents the response body.
     * 
     * The response body is streamed on demand as the Body field
     * is read. If the network connection fails or the server
     * terminates the response, Body.Read calls return an error.
     * 
     * The http Client and Transport guarantee that Body is always
     * non-nil, even on responses without a body or responses with
     * a zero-length body. It is the caller's responsibility to
     * close Body. The default HTTP client's Transport may not
     * reuse HTTP/1.x "keep-alive" TCP connections if the Body is
     * not read to completion and closed.
     * 
     * The Body is automatically dechunked if the server replied
     * with a "chunked" Transfer-Encoding.
     * 
     * As of Go 1.12, the Body will also implement io.Writer
     * on a successful "101 Switching Protocols" response,
     * as used by WebSockets and HTTP/2's "h2c" mode.
     */
    "Body": io$0.ReadCloser;

    /**
     * ContentLength records the length of the associated content. The
     * value -1 indicates that the length is unknown. Unless Request.Method
     * is "HEAD", values >= 0 indicate that the given number of bytes may
     * be read from Body.
     */
    "ContentLength": number;

    /**
     * Contains transfer encodings from outer-most to inner-most. Value is
     * nil, means that "identity" encoding is used.
     */
    "TransferEncoding": string[];

    /**
     * Close records whether the header directed that the connection be
     * closed after reading Body. The value is advice for clients: neither
     * ReadResponse nor Response.Write ever closes a connection.
     */
    "Close": boolean;

    /**
     * Uncompressed reports whether the response was sent compressed but
     * was decompressed by the http package. When true, reading from
     * Body yields the uncompressed content instead of the compressed
     * content actually set from the server, ContentLength is set to -1,
     * and the "Content-Length" and "Content-Encoding" fields are deleted
     * from the responseHeader. To get the original response from
     * the server, set Transport.DisableCompression to true.
     */
    "Uncompressed": boolean;

    /**
     * Trailer maps trailer keys to values in the same
     * format as Header.
     * 
     * The Trailer initially contains only nil values, one for
     * each key specified in the server's "Trailer" header
     * value. Those values are not added to Header.
     * 
     * Trailer must not be accessed concurrently with Read calls
     * on the Body.
     * 
     * After Body.Read has returned io.EOF, Trailer will contain
     * any trailer values sent by the server.
     */
    "Trailer": Header;

    /**
     * Request is the request that was sent to obtain this Response.
     * Request's Body is nil (having already been consumed).
     * This is only populated for Client requests.
     */
    "Request": Request | null;

    /**
     * TLS contains information about the TLS connection on which the
     * response was received. It is nil for unencrypted responses.
     * The pointer is shared between responses and should not be
     * modified.
     */
    "TLS": tls$0.ConnectionState | null;

    /** Creates a new Response instance. */
    constructor($$source: Partial<Response> = {}) {
        if (!("Status" in $$source)) {
            this["Status"] = "";
        }
        if (!("StatusCode" in $$source)) {
            this["StatusCode"] = 0;
        }
        if (!("Proto" in $$source)) {
            this["Proto"] = "";
        }
        if (!("ProtoMajor" in $$source)) {
            this["ProtoMajor"] = 0;
        }
        if (!("ProtoMinor" in $$source)) {
            this["ProtoMinor"] = 0;
        }
        if (!("Header" in $$source)) {
            this["Header"] = ({} as Header);
        }
        if (!("Body" in $$source)) {
            this["Body"] = null;
        }
        if (!("ContentLength" in $$source)) {
            this["ContentLength"] = 0;
        }
        if (!("TransferEncoding" in $$source)) {
            this["TransferEncoding"] = [];
        }
        if (!("Close" in $$source)) {
            this["Close"] = false;
        }
        if (!("Uncompressed" in $$source)) {
            this["Uncompressed"] = false;
        }
        if (!("Trailer" in $$source)) {
            this["Trailer"] = ({} as Header);
        }
        if (!("Request" in $$source)) {
            this["Request"] = null;
        }
        if (!("TLS" in $$source)) {
            this["TLS"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Response instance from a string or object.
     */
    static createFrom($$source: any = {}): Response {
        const $$createField5_0 = $$createType2;
        const $$createField8_0 = $$createType3;
        const $$createField11_0 = $$createType2;
        const $$createField12_0 = $$createType13;
        const $$createField13_0 = $$createType9;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Header" in $$parsedSource) {
            $$parsedSource["Header"] = $$createField5_0($$parsedSource["Header"]);
        }
        if ("TransferEncoding" in $$parsedSource) {
            $$parsedSource["TransferEncoding"] = $$createField8_0($$parsedSource["TransferEncoding"]);
        }
        if ("Trailer" in $$parsedSource) {
            $$parsedSource["Trailer"] = $$createField11_0($$parsedSource["Trailer"]);
        }
        if ("Request" in $$parsedSource) {
            $$parsedSource["Request"] = $$createField12_0($$parsedSource["Request"]);
        }
        if ("TLS" in $$parsedSource) {
            $$parsedSource["TLS"] = $$createField13_0($$parsedSource["TLS"]);
        }
        return new Response($$parsedSource as Partial<Response>);
    }
}

// Private type creation functions
const $$createType0 = url$0.URL.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
var $$createType2 = (function $$initCreateType2(...args): any {
    if ($$createType2 === $$initCreateType2) {
        $$createType2 = $$createType4;
    }
    return $$createType2(...args);
});
const $$createType3 = $Create.Array($Create.Any);
const $$createType4 = $Create.Map($Create.Any, $$createType3);
var $$createType5 = (function $$initCreateType5(...args): any {
    if ($$createType5 === $$initCreateType5) {
        $$createType5 = $$createType4;
    }
    return $$createType5(...args);
});
const $$createType6 = multipart$0.Form.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = tls$0.ConnectionState.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
const $$createType10 = Response.createFrom;
const $$createType11 = $Create.Nullable($$createType10);
const $$createType12 = Request.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
